#### 归约方法的优势与并行化
>相比于前面写的逐步迭代求和，使用reduce的好处在于，这里的迭代被内部迭代抽象掉
了，这让内部实现得以选择并行执行reduce操作。而迭代式求和例子要更新共享变量sum，
这不是那么容易并行化的。如果你加入了同步，很可能会发现线程竞争抵消了并行本应带来的
性能提升！这种计算的并行化需要另一种办法：将输入分块，分块求和，最后再合并起来。但
这样的话代码看起来就完全不一样了。你在第7章会看到使用分支/合并框架来做是什么样子。
但现在重要的是要认识到，可变的累加器模式对于并行化来说是死路一条。你需要一种新的模
式，这正是reduce所提供的。你还将在第7章看到，使用流来对所有的元素并行求和时，你的
代码几乎不用修改： stream()换成了parallelStream()。  
int sum = numbers.parallelStream().reduce(0, Integer::sum);  
但要并行执行这段代码也要付一定代价，我们稍后会向你解释：传递给reduce的Lambda
不能更改状态（如实例变量），而且操作必须满足结合律才可以按任意顺序执行。  

#### 流操作：无状态和有状态
>你已经看到了很多的流操作。乍一看流操作简直是灵丹妙药，而且只要在从集合生成流的
时候把Stream换成parallelStream就可以实现并行。  
当然，对于许多应用来说确实是这样，就像前面的那些例子。你可以把一张菜单变成流，
用filter选出某一类的菜肴，然后对得到的流做map来对卡路里求和，最后reduce得到菜单
的总热量。这个流计算甚至可以并行进行。但这些操作的特性并不相同。它们需要操作的内部
状态还是有些问题的。  
__诸如map或filter等操作会从输入流中获取每一个元素，并在输出流中得到0或1个结果。
这些操作一般都是无状态的：它们没有内部状态（假设用户提供的Lambda或方法引用没有内
部可变状态）__。  
但诸如reduce、 sum、 max等操作需要内部状态来累积结果。在上面的情况下，内部状态
很小。在我们的例子里就是一个int或double。不管流中有多少元素要处理，内部状态都是
有界的。  
相反，诸如sort或distinct等操作一开始都和filter和map差不多——都是接受一个
流，再生成一个流（中间操作），但有一个关键的区别。从流中排序和删除重复项时都需要知
道先前的历史。例如，排序要求所有元素都放入缓冲区后才能给输出流加入一个项目，这一操
作的存储要求是无界的。要是流比较大或是无限的，就可能会有问题（把质数流倒序会做什么
呢？它应当返回最大的质数，但数学告诉我们它不存在）。我们把这些操作叫作有__状态操作__。  

#### 中间操作和终端操作
![Alt middle_terminal_status](/image/middle_terminal_status.PNG)
